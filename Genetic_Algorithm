import traci
import subprocess
import random
import time

# === SETTINGS ===
SUMO_BINARY = "sumo"  # or "sumo-gui"
SUMO_CONFIG = "init_sim_verybasic.sumocfg"
REMOTE_PORT = 8813

NUM_GENERATIONS = 5
POPULATION_SIZE = 6
SIM_STEPS_PER_INDIVIDUAL = 1000

GREEN_MIN, GREEN_MAX = 20, 60
YELLOW_MIN, YELLOW_MAX = 3, 6

def random_tls_phases():
    return [
        random.randint(GREEN_MIN, GREEN_MAX),
        random.randint(YELLOW_MIN, YELLOW_MAX),
        random.randint(GREEN_MIN, GREEN_MAX),
        random.randint(YELLOW_MIN, YELLOW_MAX)
    ]

def create_individual(tls_ids):
    return {tls_id: random_tls_phases() for tls_id in tls_ids}

def apply_individual(tls_ids, individual):
  for tls_id in tls_ids:
        logic = traci.trafficlight.getCompleteRedYellowGreenDefinition(tls_id)[0]
        phases = logic.getPhases()

        new_phases = []
        for i, phase in enumerate(phases):
            duration = individual[tls_id][i]
            new_phase = traci.trafficlight.Phase(
                duration=duration,
                state=phase.state,
                minDur=phase.minDur,
                maxDur=phase.maxDur,
                next=phase.next
            )
            new_phases.append(new_phase)

        # Notice: Removed offset argument here
        new_logic = traci.trafficlight.Logic(
            programID=logic.programID,
            type=logic.type,
	    currentPhaseIndex=logic.currentPhaseIndex,
            phases=new_phases
        )

        traci.trafficlight.setCompleteRedYellowGreenDefinition(tls_id, new_logic)

def evaluate_emissions(steps=SIM_STEPS_PER_INDIVIDUAL):
    total_co2 = 0.0
    for _ in range(steps):
        traci.simulationStep()
        veh_ids = traci.vehicle.getIDList()
        for veh_id in veh_ids:
            try:
                total_co2 += traci.vehicle.getCO2Emission(veh_id)
            except traci.exceptions.TraCIException:
                pass
    return total_co2

def genetic_algorithm(tls_ids):
    population = [create_individual(tls_ids) for _ in range(POPULATION_SIZE)]

    for gen in range(NUM_GENERATIONS):
        print(f"\n=== Generation {gen+1} ===")
        scored_population = []

        for i, individual in enumerate(population):
            print(f"Evaluating individual {i+1}/{len(population)}...")
            traci.load(["-c", SUMO_CONFIG])
            apply_individual(tls_ids, individual)
            emissions = evaluate_emissions()
            print(f"  Total CO2 emissions: {emissions:.2f}")
            scored_population.append((emissions, individual))

        scored_population.sort(key=lambda x: x[0])
        survivors = [ind for _, ind in scored_population[:POPULATION_SIZE // 2]]

        new_population = survivors[:]
        while len(new_population) < POPULATION_SIZE:
            parent = random.choice(survivors)
            child = {}
            for tls_id in tls_ids:
                phases = parent[tls_id][:]
                idx = random.randint(0, 3)
                if idx % 2 == 0:
                    phases[idx] = random.randint(GREEN_MIN, GREEN_MAX)
                else:
                    phases[idx] = random.randint(YELLOW_MIN, YELLOW_MAX)
                child[tls_id] = phases
            new_population.append(child)

        population = new_population

    best = min(scored_population, key=lambda x: x[0])
    print("\nâœ… Best CO2 emission found:", best[0])
    return best[1]

def main():
    sumo_cmd = [SUMO_BINARY, "-c", SUMO_CONFIG, "--start", "--remote-port", str(REMOTE_PORT)]
    sumo_process = subprocess.Popen(sumo_cmd)

    traci.init(REMOTE_PORT)
    tls_ids = traci.trafficlight.getIDList()
    print("Traffic light IDs:", tls_ids)

    best_config = genetic_algorithm(tls_ids)

    print("Best TLS config:", best_config)

    apply_individual(tls_ids, best_config)
    print("Running final simulation with best config...")
    while traci.simulation.getMinExpectedNumber() > 0:
        traci.simulationStep()

    traci.close()
    sumo_process.wait()

if __name__ == "__main__":
    main()
